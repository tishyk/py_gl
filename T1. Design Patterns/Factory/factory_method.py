# Factory/shapefact1/ShapeFactory1.py
# A simple static factory method.
#from __future__ import generators  # for subclasses access in python 2.x
import random


class Shape:
    # Create based on class name:
    def factory(type):
        # return eval(type + "()")
        if type == "Circle":
            return Circle()
        if type == "Square":
            return Square()
        assert 0, "Bad shape creation: " + type

    factory = staticmethod(factory)


class Circle(Shape):
    def draw(self):
        print("Circle.draw")

    def erase(self):
        print("Circle.erase")


class Square(Shape):
    def draw(self):
        print("Square.draw")

    def erase(self):
        print("Square.erase")


# Generate shape name strings:
def shapeNameGen(n):
    types = Shape.__subclasses__()
    for i in range(n):
        yield random.choice(types).__name__


shapes = [Shape.factory(i) for i in shapeNameGen(7)]

for shape in shapes:
    shape.draw()
    shape.erase()


"""
Inside the generator-factory, you can see the call to __subclasses__( ), which produces a list of references to each of
the subclasses of Shape (which must be inherited from object for this to work). You should be aware,
however, that this only works for the first level of inheritance from Item,
so if you were to inherit a new class from Circle, it wouldn’t show up in the list generated by __subclasses__( ).
If you need to create a deeper hierarchy this way, you must recurse the __subclasses__( ) list.

Also note that in shapeNameGen( ) the statement:

types = Shape.__subclasses__()
Is only executed when the generator object is produced; each time the next( ) method of this generator object is called
(which, as noted above, may happen implicitly), only the code in the for loop will be executed,
so you don’t have wasteful execution (as you would if this were an ordinary function)."""